"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Ledger = void 0;
Object.defineProperty(exports, "packageInfo", {
  enumerable: true,
  get: function () {
    return _packageInfo.packageInfo;
  }
});
var _ledgerSubstrate = require("@zondax/ledger-substrate");
var _hwLedgerTransports = require("@polkadot/hw-ledger-transports");
var _util = require("@polkadot/util");
var _constants = require("./constants");
var _defaults = require("./defaults");
var _packageInfo = require("./packageInfo");
// Copyright 2017-2023 @polkadot/hw-ledger authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal Wraps a SubstrateApp call, checking the result for any errors which result in a rejection */
async function wrapError(promise) {
  const result = await promise;
  if (result.return_code !== _constants.LEDGER_SUCCESS_CODE) {
    throw new Error(result.error_message);
  }
  return result;
}

// A very basic wrapper for a ledger app -
//  - it connects automatically, creating an app as required
//  - Promises return errors (instead of wrapper errors)
class Ledger {
  #app = null;
  #chain;
  #transport;
  constructor(transport, chain) {
    // u2f is deprecated
    if (!['hid', 'webusb'].includes(transport)) {
      throw new Error(`Unsupported transport ${transport}`);
    } else if (!Object.keys(_defaults.ledgerApps).includes(chain)) {
      throw new Error(`Unsupported chain ${chain}`);
    }
    this.#chain = chain;
    this.#transport = transport;
  }
  async getAddress() {
    let confirm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let accountOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let addressOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let {
      account = _constants.LEDGER_DEFAULT_ACCOUNT,
      addressIndex = _constants.LEDGER_DEFAULT_INDEX,
      change = _constants.LEDGER_DEFAULT_CHANGE
    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return this.#withApp(async app => {
      const {
        address,
        pubKey
      } = await wrapError(app.getAddress(account + accountOffset, change, addressIndex + addressOffset, confirm));
      return {
        address,
        publicKey: (0, _util.hexAddPrefix)(pubKey)
      };
    });
  }
  async getVersion() {
    return this.#withApp(async app => {
      const {
        device_locked: isLocked,
        major,
        minor,
        patch,
        test_mode: isTestMode
      } = await wrapError(app.getVersion());
      return {
        isLocked,
        isTestMode,
        version: [major, minor, patch]
      };
    });
  }
  async sign(message) {
    let accountOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let addressOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let {
      account = _constants.LEDGER_DEFAULT_ACCOUNT,
      addressIndex = _constants.LEDGER_DEFAULT_INDEX,
      change = _constants.LEDGER_DEFAULT_CHANGE
    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return this.#withApp(async app => {
      const buffer = (0, _util.u8aToBuffer)(message);
      const {
        signature
      } = await wrapError(app.sign(account + accountOffset, change, addressIndex + addressOffset, buffer));
      return {
        signature: (0, _util.hexAddPrefix)(signature.toString('hex'))
      };
    });
  }
  #getApp = async () => {
    if (!this.#app) {
      const def = _hwLedgerTransports.transports.find(_ref => {
        let {
          type
        } = _ref;
        return type === this.#transport;
      });
      if (!def) {
        throw new Error(`Unable to find a transport for ${this.#transport}`);
      }
      const transport = await def.create();
      this.#app = (0, _ledgerSubstrate.newSubstrateApp)(transport, _defaults.ledgerApps[this.#chain]);
    }
    return this.#app;
  };
  #withApp = async fn => {
    try {
      const app = await this.#getApp();
      return await fn(app);
    } catch (error) {
      this.#app = null;
      throw error;
    }
  };
}
exports.Ledger = Ledger;